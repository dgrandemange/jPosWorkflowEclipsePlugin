=Primary needs=
In [http://www.jpos.org/ jPos], the transaction manager component  takes care of ''driving'' the transaction. To do so,  it relies on smaller units called participants. Participants are components through which the transaction flow may pass. Thus, the jPos transaction manager implementation design enhances code reuse and componentization. The transaction manager provides also some routing functionalities thanks to the ''org.jpos.transaction.GroupSelector''  interface.
Transaction manager is configured via a dedicated XML configuration.
See [http://www.jpos.org/products/proguide jPOS programmer's guide] §10 for more details.

The way a transaction is processed may vary, depending on many criteria.
For instance, the transaction type (activation, payment, cancellation ...) may change the way the transaction should be processed. Also, further in the processing, you may have to choose between different processing paths depending on many criteria : card's validity check result, acquirer response (acceptation, reject), ...

When wondering how to efficiently work on transaction manager configuration, and thinking about a process allowing to work incrementally on it so that it can easily be communicated to other people (maybe more business oriented people), one can not simply answer : edit transaction manager's XML configuration and it's done.

Having a graphical view would be much more talkative. Besides, a graphical representation (say a diagram state representation for instance) is easier to communicate to non developer people. Editing a workflow in an UML editor is a solution, but edition work needs to be done twice. And what if the workflow often changes ? This is not a very responsive process, with  the risk to loose informations. Eventually, it would be nice if we were able to generate a graphical view on the fly (and at will) straight from the XML transaction manager configuration itself.

Thinking of a graphical representation as a state diagram along its ''states'' and ''transitions'', there would be the transaction participants as ''states'' . But what about ''transitions''? Nothing in a transaction manager configuration formally identifies transitions between a participant and a group. But, taking a further look at §10.8 of jPOS programmer's guide, the configuration sample clearly shows that some properties are used for this purpose and hold a ''transition'' function.  In this sample, we can see properties which gives a list of groups to pass through, depending on the message type (0100, 0200,...). Obviously, theses properties can be used as transitions.

<pre>     ...</pre>
<pre>     </pre>
<pre>     <participant class="org.jpos.my.Switch" logger="Q2"></pre>
<pre>     	< !--</pre>
<pre>     		If MTI is 0100, route to the following participants groups : </pre>
<pre>     		- Authorization,</pre>
<pre>     		- Response,</pre>
<pre>     		- Log</pre>
<pre>     	-- ></pre>
<pre>     	<property name="0100" value="Authorization Response Log" /></pre>
<pre>     	</pre>
<pre>     	< !--</pre>
<pre>     		If MTI is 0200, route to the following participants groups : </pre>
<pre>     		- Financial,</pre>
<pre>     		- Response,</pre>
<pre>     		- Log</pre>
<pre>     	-- ></pre>
<pre>     	<property name="0200" value="Financial Response Log" /></pre>
<pre>     </pre>
<pre>     	<property name="0220" value="Notification Response Log" /></pre>
<pre>     	<property name="0221" value="Notification Response Log" /></pre>
<pre>     	<property name="0420" value="Reversal Response Log" /></pre>
<pre>     	<property name="0421" value="Reversal Response Log" /></pre>
<pre>     	<property name="0500" value="BatchManagement Response Log" /></pre>
<pre>     	<property name="0421" value="Reversal Response Log" /></pre>
<pre>     	<property name="0800" value="NetworkManagement Response Log" /></pre>
<pre>     </participant></pre>
<pre>     </pre>
<pre>     ...</pre>
<pre>     </pre>
<pre>     <group name="Financial"></pre>
<pre>     	<participant class="com.my.company.CheckRequiredFields"></pre>
<pre>     	<property name="fields" value="0,3,4,17,49,32,41,43,37,PAN,AMOUNT" /></pre>
<pre>     	</participant></pre>
<pre>     	<participant class="com.my.company.CheckCurrency" /></pre>
<pre>     	</pre>
<pre>     	...</pre>
<pre>     	</pre>
<pre>     </group></pre>
<pre>     </pre>
<pre>     <group name="Reversal"></pre>
<pre>     	...</pre>
<pre>     </group></pre>
<pre>     </pre>
<pre>     ...</pre>

=The jPos Workflow Eclipse plugin=
Keeping all of this in mind, a specific Eclipse plugin has been written which at this point provides  :
* conversion of a transaction manager configuration into a directed graph model,
* reduction of the previously generated directed graph,
* graphical view of the reduced graph in a dedicated Eclipse editor,
* image export of Eclipse view (JPG, PNG), 
* GraphViz format export (DOT) for enhanced rendering

Resulting design constraints are :
* keep the transaction participants as atomic as possible, 
* clearly identify transitions properties. In order for the plugin to work, those properties should be formally marked with a special attribute named ''selectCriterion'' , whose value should briefly describe the transition,
* avoid circular references

After adapting the previous transaction manager configuration excerpt to suit these constraints, we obtain the following configuration :

<pre><txnmgr name="kdoTxn" logger="Q2"	class="org.jpos.transaction.TransactionManager"></pre>
<pre></pre>
<pre>	<participant class="org.jpos.my.Switch" logger="Q2"></pre>
<pre>	</pre>
<pre>		<property name="0100" value="Authorization Response Log" </pre>
<pre>			selectCriterion="incoming message 0100" /></pre>
<pre>			</pre>
<pre>		<property name="0200" value="Financial Response Log"</pre>
<pre>			 selectCriterion="incoming message 0200" /></pre>
<pre>			 </pre>
<pre>		<property name="0220" value="Notification Response Log" </pre>
<pre>			selectCriterion="incoming message 0220" /></pre>
<pre>			</pre>
<pre>		<property name="0221" value="Notification Response Log" </pre>
<pre>			selectCriterion="incoming message 0221" /></pre>
<pre>			</pre>
<pre>		<property name="0420" value="Reversal Response Log" </pre>
<pre>			selectCriterion="incoming message 0420" /></pre>
<pre>		</pre>
<pre>		<property name="0421" value="Reversal Response Log" </pre>
<pre>			selectCriterion="incoming message 0421" /></pre>
<pre>		</pre>
<pre>		<property name="0500" value="BatchManagement Response Log" </pre>
<pre>			selectCriterion="incoming message 0500" /></pre>
<pre>		</pre>
<pre>		<property name="0421" value="Reversal Response Log" </pre>
<pre>			selectCriterion="incoming message 0421" /></pre>
<pre>		</pre>
<pre>		<property name="0800" value="NetworkManagement Response Log" </pre>
<pre>			selectCriterion="incoming message 0800" /></pre>
<pre>	</participant></pre>
<pre>	</pre>
<pre>	<group name="Financial"></pre>
<pre>		</pre>
<pre>		<participant class="com.my.company.CheckRequiredFields"></pre>
<pre>			<property name="fields" value="0,3,4,17,49,32,41,43,37,PAN,AMOUNT" /></pre>
<pre>		</participant></pre>
<pre>		</pre>
<pre>		<participant class="com.my.company.CheckCurrency" /></pre>
<pre>		</pre>
<pre>	</group></pre>
<pre>	</pre>
<pre>	< !-- TODO :  configuration to complete -- ></pre>
<pre>	</pre>
<pre></txnmgr></pre>

After right-clicking this XML configuration file in the Eclipse Package Explorer view, item menu  ''jPos Workflow -> view graph'' should show up. 

Left-clicking it should open a jPos Workflow view with a graphical representation of the selected configuration :
[[https://github.com/dgrandemange/jPosWorkflowEclipsePlugin/raw/master/wikidoc/workflowplugin_dummy.jpg|align=center]]

About this view : 
* if somewhere in the transaction manager configuration, a non yet declared participant/group is referenced, its icon shows up in red color, 
* transition informations can be seen by mouse over on ''information'' icons; if you have use context management annotations on your participant classes, thse informations also show up,
* double-clicking on a participant node may open the Java source of the associated participant class (provided it exists in your project),
* as the number of nodes and transitions may grow quickly, the Eclipse GEF graph layout at some point may become hardly readable; consider then using DOT export for a further GraphViz rendering.

==GraphViz DOT export==
Also, right clicking on jPos Workflow view, you may be able to export the graph as a DOT file (GraphViz format). 

Here is the generated DOT source after such export : 

<pre><nowiki>digraph "JPos Workflow Eclipse Plugin DOT Export" {</nowiki></pre>
<pre><nowiki>node [shape="box" peripheries="1" style="filled" color="#000000" fillcolor="#FFFFCE" fontname="Arial" fontsize="10"]</nowiki></pre>
<pre><nowiki>n1 [label="Switch"]</nowiki></pre>
<pre><nowiki>n23 [label="Log:<undefined>"]</nowiki></pre>
<pre><nowiki>n22 [label="Response:<undefined>"]</nowiki></pre>
<pre><nowiki>FINAL [label="" shape="circle" peripheries="2" style="filled" color="#000000" fillcolor="#000000"]</nowiki></pre>
<pre><nowiki>n21 [label="Reversal:<undefined>"]</nowiki></pre>
<pre><nowiki>n3 [label="CheckCurrency"]</nowiki></pre>
<pre><nowiki>n2 [label="CheckRequiredFields"]</nowiki></pre>
<pre><nowiki>n9 [label="Notification:<undefined>"]</nowiki></pre>
<pre><nowiki>n6 [label="NetworkManagement:<undefined>"]</nowiki></pre>
<pre><nowiki>INITIAL [label="" shape="circle" peripheries="1" style="filled" color="#000000" fillcolor="#000000"]</nowiki></pre>
<pre><nowiki>n24 [label="Authorization:<undefined>"]</nowiki></pre>
<pre><nowiki>n15 [label="BatchManagement:<undefined>"]</nowiki></pre>
<pre><nowiki>edge [fontname="Arial" fontsize="8" dir="forward" arrowhead="normal"]</nowiki></pre>
<pre><nowiki>n3 -> n22 [label=""]</nowiki></pre>
<pre><nowiki>n22 -> n23 [label=""]</nowiki></pre>
<pre><nowiki>n6 -> n22 [label=""]</nowiki></pre>
<pre><nowiki>n1 -> n9 [label="incoming message 0221"]</nowiki></pre>
<pre><nowiki>n15 -> n22 [label=""]</nowiki></pre>
<pre><nowiki>n21 -> n22 [label=""]</nowiki></pre>
<pre><nowiki>n9 -> n22 [label=""]</nowiki></pre>
<pre><nowiki>n1 -> n21 [label="incoming message 0420"]</nowiki></pre>
<pre><nowiki>n1 -> n6 [label="incoming message 0800"]</nowiki></pre>
<pre><nowiki>n1 -> n15 [label="incoming message 0500"]</nowiki></pre>
<pre><nowiki>n23 -> FINAL [label=""]</nowiki></pre>
<pre><nowiki>n1 -> n24 [label="incoming message 0100"]</nowiki></pre>
<pre><nowiki>n24 -> n22 [label=""]</nowiki></pre>
<pre><nowiki>INITIAL -> n1 [label=""]</nowiki></pre>
<pre><nowiki>n1 -> n2 [label="incoming message 0200"]</nowiki></pre>
<pre><nowiki>n2 -> n3 [label=""]</nowiki></pre>
<pre><nowiki>}</nowiki></pre>

and here is GraphViz rendering of this DOT source :
[[https://github.com/dgrandemange/jPosWorkflowEclipsePlugin/raw/master/wikidoc/workflowplugin_dot_graphviz_view.jpg|align=center]]

You may install the [http://sourceforge.net/projects/eclipsegraphviz/ Eclipse GraphViz plugin] for rendering inside your Eclipse IDE.

==Context management informations==
If your participant classes are annotated with context management annotations, the plugin uses them.

===About context management annotations===
<p>These annotations may be used on participant classes (implementing jPos TransactionParticipant or GroupSelector interfaces).Simply said, these annotations are a way to explicitly declare which context attributes may be updated after participant's processing.</p>
<p>As these are only annotations, it does not ensure that the coder effectively update the context accordingly to the annotations updating rules. 
Therefore it may be a good idea to restrict direct access to the transaction context object from within the participants, and delegate the context management to a service or something that relies on the context management annotations to do the job.
You may also think of an annotation processor that will make some consistency checks at compilation time.</p>

====Using annotations in participant : typical usage====
<pre>
package org.jpos.jposext.jposworkflow.sample.participant;

import org.jpos.jposext.ctxmgmt.annotation.UpdateContextRule;
import org.jpos.jposext.ctxmgmt.annotation.UpdateContextRules;

@UpdateContextRules({
		@UpdateContextRule(attrNames = CheckRequiredFields.REQUIREDFLD_ATTR0),
		@UpdateContextRule(id = CheckRequiredFields.TRANSITION__CHECKED_OK, attrNames = { CheckRequiredFields.REQUIREDFLD_ATTR1, CheckRequiredFields.REQUIREDFLD_ATTR2, CheckRequiredFields.REQUIREDFLD_ATTR3}),
		@UpdateContextRule(id = CheckRequiredFields.TRANSITION__CHECKED_KO, attrNames = { CheckRequiredFields.REQUIREDFLD_ATTR4, CheckRequiredFields.REQUIREDFLD_ATTR5}) })
public class CheckRequiredFields extends AbstractGroupSelectorParticipant{

	protected static final String TRANSITION__CHECKED_KO = "CHECKED_KO";
	protected static final String TRANSITION__CHECKED_OK = "CHECKED_OK";
	
	protected static final String REQUIREDFLD_ATTR0 = "requiredfld.attr0";
	protected static final String REQUIREDFLD_ATTR1 = "requiredfld.attr1";
	protected static final String REQUIREDFLD_ATTR2 = "requiredfld.attr2";
	protected static final String REQUIREDFLD_ATTR3 = "requiredfld.attr3";
	protected static final String REQUIREDFLD_ATTR4 = "requiredfld.attr4";
	protected static final String REQUIREDFLD_ATTR5 = "requiredfld.attr5";

	/* (non-Javadoc)
	 * @see org.jpos.jposext.jposworkflow.sample.participant.AbstractGroupSelectorParticipant#prepare(long)
	 */
	public int prepare(long id) {

		// always add attribute REQUIREDFLD_ATTR0 to context
		ctxPutForId(UpdateContextRule.DEFAULT_ID, "value0");
		
		// NB : method ctxPutForId() should be inherited from parent class AbstractGroupSelectorParticipant
		// and knows how to update current transaction context using current class @UpdateContextRules annotation

		return PREPARED | NO_JOIN;
	}

	/* (non-Javadoc)
	 * @see org.jpos.jposext.jposworkflow.sample.participant.AbstractGroupSelectorParticipant#select(long)
	 */
	public String select(long id) {
		String transitionId;		
		boolean checked = false;
		// do checks here ...

		if (checked) {
			// Fields checked
			transitionId = TRANSITION__CHECKED_OK;
			
			// Update context according to @UpdateContextRule of id 'CHECKED_OK', passing respective attribute values as arguments 
			ctxPutForId(transitionId, "attr1value", "attr2value", "attr3value");
		} else {
			transitionId = TRANSITION__CHECKED_KO;
			
			// Update context according to @UpdateContextRule of id 'CHECKED_KO', passing respective attribute values as arguments
			ctxPutForId(transitionId, "attr4value", "attr5value");
		}
 
		// Looking in current participant configuration for next participants/groups
		return getConfig().get(transitionId);	
	}

}
</pre>

===How does the plugin use context management annotations ?===
====Participant node tool tip====
Mousing over a simple TransactionParticipant node, it shows up the list of context attributes that are updated by the participant.

Dealing with a GroupSelector, depending on the outcome transition, extra context attributes may be updated. Mousing over such node shows up the list of context attributes indexed by outcomed transition.

====Transition tool tip====
<p>Mousing over a transition edge shows up every attributes that are guaranteed to be present in the context at this point of the workflow.</p>
<p>Now, as the graph is reduced (common branches of the original graph tree are merged as much as possible), looking to the end of the workflow of our switch transaction manager configuration above, we can see just one ''Response'' participant with a transition to one ''Log'' participant. That's because this part is common to every processing (athorization, notification, finanacial, reversal, ...). Looking back at the beginning of the workflow, the ''authorization'' processing may put some particular attributes in the context whereas the ''notification'' processing may put some others. And maybe they also both share some commons attributes in the process.</p>
<p>Mousing over the late transition of the workflow, plugin shows up not only the common attributes guaranteed to be set in the context, but also the ones that may be set somewhere in the parent branches.</p>
This may reveal helpful at some point of the workflow, when one of your participant need to get one attribute from the context, and you want make sure this attribute present at that point.